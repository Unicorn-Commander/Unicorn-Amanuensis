#!/usr/bin/env python3
"""
Mel Filterbank Coefficient Generator for Whisper on AMD Phoenix NPU
Generates Q15 fixed-point triangular mel filters following HTK formula

Generates: mel_filterbank_coeffs.h
Author: Magic Unicorn Inc.
Date: October 28, 2025
"""

import numpy as np
import argparse
from pathlib import Path


def hz_to_mel_htk(hz):
    """Convert Hz to mel scale using HTK formula (used by Whisper)"""
    return 2595.0 * np.log10(1.0 + hz / 700.0)


def mel_to_hz_htk(mel):
    """Convert mel to Hz using HTK formula (used by Whisper)"""
    return 700.0 * (10.0 ** (mel / 2595.0) - 1.0)


def generate_mel_filters(num_mels=80, sample_rate=16000, n_fft=512):
    """
    Generate mel filterbank following Whisper specification

    Args:
        num_mels: Number of mel bins (80 for Whisper)
        sample_rate: Audio sample rate (16000 Hz for Whisper)
        n_fft: FFT size (512 for Whisper)

    Returns:
        List of filter dictionaries with start/peak/end bins and coefficients
    """
    # Frequency range: 0 to Nyquist (8000 Hz for 16 kHz sampling)
    fmin = 0.0
    fmax = sample_rate / 2.0

    # Convert to mel scale
    mel_min = hz_to_mel_htk(fmin)
    mel_max = hz_to_mel_htk(fmax)

    # Create mel_bins + 2 equally spaced points in mel space
    mel_points = np.linspace(mel_min, mel_max, num_mels + 2)

    # Convert back to Hz
    hz_points = mel_to_hz_htk(mel_points)

    # Convert Hz to FFT bin indices
    # We use first 256 bins (positive frequencies) from 512-point FFT
    num_fft_bins = n_fft // 2  # 256 bins
    freq_per_bin = sample_rate / n_fft  # 31.25 Hz per bin

    bin_points = np.floor((n_fft + 1) * hz_points / sample_rate).astype(int)

    # Ensure bin indices are within valid range
    bin_points = np.clip(bin_points, 0, num_fft_bins - 1)

    filters = []

    for i in range(num_mels):
        # Triangular filter boundaries
        left_bin = bin_points[i]
        center_bin = bin_points[i + 1]
        right_bin = bin_points[i + 2]

        # Skip degenerate filters (should not happen with proper spacing)
        if left_bin == right_bin:
            continue

        # Compute left slope (rising edge)
        left_width = center_bin - left_bin
        left_slopes = []
        if left_width > 0:
            for j in range(left_width):
                # Linear rise from 0.0 to 1.0
                weight = (j + 1) / left_width
                # Convert to Q15: 1.0 = 32767
                q15_value = int(weight * 32767.0)
                left_slopes.append(q15_value)

        # Compute right slope (falling edge)
        right_width = right_bin - center_bin
        right_slopes = []
        if right_width > 0:
            for j in range(right_width):
                # Linear fall from 1.0 to 0.0
                weight = 1.0 - (j + 1) / right_width
                # Convert to Q15
                q15_value = int(weight * 32767.0)
                right_slopes.append(q15_value)

        filter_info = {
            'id': i,
            'start_bin': left_bin,
            'peak_bin': center_bin,
            'end_bin': right_bin,
            'left_slopes': left_slopes,
            'right_slopes': right_slopes,
            'center_freq_hz': hz_points[i + 1],
            'center_freq_mel': mel_points[i + 1]
        }

        filters.append(filter_info)

    return filters


def generate_header_file(filters, output_path):
    """Generate C header file with mel filterbank coefficients"""

    # Find maximum filter width for array sizing
    max_left_width = max(len(f['left_slopes']) for f in filters)
    max_right_width = max(len(f['right_slopes']) for f in filters)
    max_width = max(max_left_width, max_right_width)

    # Total filter width (for validation)
    max_total_width = max(f['end_bin'] - f['start_bin'] for f in filters)

    with open(output_path, 'w') as f:
        f.write("""// Mel Filterbank Coefficients for Whisper (Q15 Fixed-Point)
// Auto-generated by generate_mel_filterbank.py
// For AMD Phoenix NPU - 80 triangular mel filters @ 16 kHz
//
// Specification:
//   - 80 mel bins (Whisper standard)
//   - HTK mel scale: mel = 2595 * log10(1 + f/700)
//   - Triangular filters with ~50% overlap
//   - Q15 format: 1.0 = 32767, 0.5 = 16384
//   - Input: 256 magnitude bins from 512-point FFT
//   - Frequency range: 0-8000 Hz (Nyquist at 16 kHz)

#ifndef MEL_FILTERBANK_COEFFS_H
#define MEL_FILTERBANK_COEFFS_H

#include <stdint.h>

// Maximum filter width (in FFT bins)
""")
        f.write(f"#define MEL_MAX_FILTER_WIDTH {max_total_width}\n")
        f.write(f"#define MEL_MAX_LEFT_WIDTH {max_left_width}\n")
        f.write(f"#define MEL_MAX_RIGHT_WIDTH {max_right_width}\n")
        f.write(f"#define NUM_MEL_FILTERS 80\n\n")

        f.write("""// Mel filter structure (Q15 format)
typedef struct {
    uint16_t start_bin;    // First non-zero bin
    uint16_t peak_bin;     // Peak of triangle (weight = 1.0)
    uint16_t end_bin;      // Last non-zero bin
    uint16_t left_width;   // Number of bins in left slope
    uint16_t right_width;  // Number of bins in right slope
    const int16_t* left_slopes;   // Pointer to left slope coefficients (Q15)
    const int16_t* right_slopes;  // Pointer to right slope coefficients (Q15)
} mel_filter_t;

""")

        # Generate coefficient arrays for each filter
        f.write("// Filter coefficient arrays\n")
        for filt in filters:
            filt_id = filt['id']

            # Left slopes
            if filt['left_slopes']:
                f.write(f"static const int16_t mel_{filt_id}_left[{len(filt['left_slopes'])}] = {{")
                for j, coeff in enumerate(filt['left_slopes']):
                    if j % 8 == 0:
                        f.write("\n    ")
                    f.write(f"{coeff:5d}")
                    if j < len(filt['left_slopes']) - 1:
                        f.write(", ")
                f.write("\n};\n")

            # Right slopes
            if filt['right_slopes']:
                f.write(f"static const int16_t mel_{filt_id}_right[{len(filt['right_slopes'])}] = {{")
                for j, coeff in enumerate(filt['right_slopes']):
                    if j % 8 == 0:
                        f.write("\n    ")
                    f.write(f"{coeff:5d}")
                    if j < len(filt['right_slopes']) - 1:
                        f.write(", ")
                f.write("\n};\n")

            f.write("\n")

        # Generate main filter array
        f.write("// Main mel filterbank array\n")
        f.write("static const mel_filter_t mel_filters[NUM_MEL_FILTERS] = {\n")

        for filt in filters:
            filt_id = filt['id']
            f.write(f"    {{ // Filter {filt_id}: {filt['center_freq_hz']:.1f} Hz ({filt['center_freq_mel']:.1f} mel)\n")
            f.write(f"        .start_bin = {filt['start_bin']},\n")
            f.write(f"        .peak_bin = {filt['peak_bin']},\n")
            f.write(f"        .end_bin = {filt['end_bin']},\n")
            f.write(f"        .left_width = {len(filt['left_slopes'])},\n")
            f.write(f"        .right_width = {len(filt['right_slopes'])},\n")

            if filt['left_slopes']:
                f.write(f"        .left_slopes = mel_{filt_id}_left,\n")
            else:
                f.write(f"        .left_slopes = NULL,\n")

            if filt['right_slopes']:
                f.write(f"        .right_slopes = mel_{filt_id}_right\n")
            else:
                f.write(f"        .right_slopes = NULL\n")

            f.write("    }")
            if filt_id < len(filters) - 1:
                f.write(",")
            f.write("\n")

        f.write("};\n\n")

        f.write("""// Helper function to apply single mel filter
// Returns mel energy in Q15 format
static inline int16_t apply_mel_filter(const int16_t* magnitude, const mel_filter_t* filter) {
    int32_t energy = 0;  // Accumulate in Q30 (Q15 × Q15)

    // Apply left slope (rising edge)
    for (int i = 0; i < filter->left_width; i++) {
        int bin_idx = filter->start_bin + i;
        int16_t mag = magnitude[bin_idx];
        int16_t weight = filter->left_slopes[i];

        // Q15 × Q15 = Q30
        energy += (int32_t)mag * (int32_t)weight;
    }

    // Apply right slope (falling edge)
    for (int i = 0; i < filter->right_width; i++) {
        int bin_idx = filter->peak_bin + i;
        int16_t mag = magnitude[bin_idx];
        int16_t weight = filter->right_slopes[i];

        // Q15 × Q15 = Q30
        energy += (int32_t)mag * (int32_t)weight;
    }

    // Convert Q30 back to Q15 (divide by 2^15)
    // Add rounding: (energy + 2^14) >> 15
    int32_t rounded = (energy + (1 << 14)) >> 15;

    // Clamp to INT16 range
    if (rounded > 32767) rounded = 32767;
    if (rounded < -32768) rounded = -32768;

    return (int16_t)rounded;
}

#endif // MEL_FILTERBANK_COEFFS_H
""")

    print(f"✅ Generated {output_path}")
    print(f"   - 80 mel filters")
    print(f"   - Max filter width: {max_total_width} bins")
    print(f"   - Max left slope: {max_left_width} bins")
    print(f"   - Max right slope: {max_right_width} bins")
    print(f"   - Frequency range: 0-8000 Hz")
    print(f"   - Format: Q15 fixed-point")


def validate_filters(filters):
    """Validate mel filter properties"""
    print("\n📊 Filter Validation:")

    # Check filter count
    print(f"   - Number of filters: {len(filters)}")
    assert len(filters) == 80, "Expected 80 filters for Whisper"

    # Check filter coverage
    min_start = min(f['start_bin'] for f in filters)
    max_end = max(f['end_bin'] for f in filters)
    print(f"   - FFT bin coverage: {min_start} to {max_end} (out of 256)")

    # Check overlap
    overlaps = []
    for i in range(len(filters) - 1):
        overlap = filters[i]['end_bin'] - filters[i+1]['start_bin']
        overlaps.append(overlap)

    avg_overlap = np.mean(overlaps)
    print(f"   - Average overlap: {avg_overlap:.1f} bins")

    # Check Q15 range
    all_coeffs = []
    for f in filters:
        all_coeffs.extend(f['left_slopes'])
        all_coeffs.extend(f['right_slopes'])

    if all_coeffs:
        min_coeff = min(all_coeffs)
        max_coeff = max(all_coeffs)
        print(f"   - Coefficient range: {min_coeff} to {max_coeff} (Q15: 0 to 32767)")
        assert 0 <= min_coeff <= 32767, "Coefficient out of Q15 range"
        assert 0 <= max_coeff <= 32767, "Coefficient out of Q15 range"

    # Memory estimate
    total_coeffs = sum(len(f['left_slopes']) + len(f['right_slopes']) for f in filters)
    memory_bytes = total_coeffs * 2 + len(filters) * 16  # 2 bytes per coeff + struct overhead
    print(f"   - Total coefficients: {total_coeffs}")
    print(f"   - Estimated memory: {memory_bytes} bytes (~{memory_bytes/1024:.1f} KB)")

    print("✅ Validation passed!")


def compare_with_librosa(filters):
    """Optional: Compare with librosa for validation"""
    try:
        import librosa

        print("\n🔍 Comparing with librosa reference:")

        # Generate librosa mel filterbank
        lib_filters = librosa.filters.mel(
            sr=16000,
            n_fft=512,
            n_mels=80,
            fmin=0.0,
            fmax=8000.0,
            htk=True  # Use HTK formula like Whisper
        )

        # Compare a few filters
        sample_indices = [0, 20, 40, 60, 79]

        for idx in sample_indices:
            our_filter = filters[idx]
            lib_filter = lib_filters[idx]

            # Find non-zero region in librosa filter
            nonzero = np.where(lib_filter > 0.001)[0]
            if len(nonzero) > 0:
                lib_start = nonzero[0]
                lib_end = nonzero[-1]
                lib_peak = nonzero[np.argmax(lib_filter[nonzero])]

                print(f"   Filter {idx}:")
                print(f"     Our:     start={our_filter['start_bin']:3d}, peak={our_filter['peak_bin']:3d}, end={our_filter['end_bin']:3d}")
                print(f"     Librosa: start={lib_start:3d}, peak={lib_peak:3d}, end={lib_end:3d}")

                # Check if reasonably close (within 2 bins)
                if abs(our_filter['start_bin'] - lib_start) <= 2 and \
                   abs(our_filter['peak_bin'] - lib_peak) <= 2 and \
                   abs(our_filter['end_bin'] - lib_end) <= 2:
                    print(f"     ✅ Match!")
                else:
                    print(f"     ⚠️  Difference detected")

        print("✅ Librosa comparison complete")

    except ImportError:
        print("\n⚠️  librosa not installed - skipping comparison")
        print("   Install with: pip install librosa")


def main():
    parser = argparse.ArgumentParser(
        description='Generate mel filterbank coefficients for Whisper NPU kernel'
    )
    parser.add_argument(
        '--output',
        type=str,
        default='mel_filterbank_coeffs.h',
        help='Output header file path (default: mel_filterbank_coeffs.h)'
    )
    parser.add_argument(
        '--validate-librosa',
        action='store_true',
        help='Compare with librosa implementation'
    )

    args = parser.parse_args()

    print("🦄 Mel Filterbank Generator for Whisper on AMD Phoenix NPU")
    print("=" * 70)
    print()
    print("Specification:")
    print("  - 80 mel bins (Whisper standard)")
    print("  - Sample rate: 16000 Hz")
    print("  - FFT size: 512 (256 positive frequency bins)")
    print("  - Mel scale: HTK formula (2595 * log10(1 + f/700))")
    print("  - Format: Q15 fixed-point (INT16)")
    print()

    # Generate filters
    print("Generating mel filters...")
    filters = generate_mel_filters(num_mels=80, sample_rate=16000, n_fft=512)

    # Validate
    validate_filters(filters)

    # Compare with librosa if requested
    if args.validate_librosa:
        compare_with_librosa(filters)

    # Generate header file
    print()
    output_path = Path(args.output)
    generate_header_file(filters, output_path)

    print()
    print("✨ Complete! Next steps:")
    print("   1. Include mel_filterbank_coeffs.h in your kernel")
    print("   2. Use mel_filters[] array to apply filterbank")
    print("   3. Call apply_mel_filter() for each mel bin")
    print()
    print("Example usage in C:")
    print("""
    #include "mel_filterbank_coeffs.h"

    void compute_mel_spectrum(int16_t* magnitude, int8_t* mel_output) {
        for (int i = 0; i < NUM_MEL_FILTERS; i++) {
            int16_t mel_energy = apply_mel_filter(magnitude, &mel_filters[i]);

            // Convert Q15 to INT8 (scale to 0-127)
            mel_output[i] = (int8_t)((mel_energy * 127) / 32767);
        }
    }
    """)


if __name__ == '__main__':
    main()
